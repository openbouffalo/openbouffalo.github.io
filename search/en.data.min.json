[{"id":0,"href":"/","title":"","parent":"","content":" open-bouffalo Hello world!\n","description":"open-bouffalo Hello world!"},{"id":1,"href":"/chips/bl60x/","title":"BL60X","parent":"Chips","content":" - BL602 BL604 GPIOs 16 23 Package QFN32 QFN40 ","description":" - BL602 BL604 GPIOs 16 23 Package QFN32 QFN40 "},{"id":2,"href":"/chips/bl70x/","title":"BL70X","parent":"Chips","content":" - BL702 BL704 BL706 GPIOs 15 23 31 Package QFN30 QFN40 QFN48 ","description":" - BL702 BL704 BL706 GPIOs 15 23 31 Package QFN30 QFN40 QFN48 "},{"id":3,"href":"/chips/bl808/","title":"BL808","parent":"Chips","content":"","description":""},{"id":4,"href":"/chips/boot-header/","title":"Boot Header","parent":"Chips","content":" Kaitai Script meta: id: bfnp file-extension: bin endian: le seq: - id: magic_code contents: \u0026#34;BFNP\u0026#34; - id: revision type: u4 - id: flash_cfg type: flash_cfg - id: clk_cfg type: clk_cfg - id: boot_cfg type: boot_cfg - id: segment_info type: u4 - id: boot_entry type: u4 - id: flash_offset type: u4 - id: hash size: 32 - id: rsv1 type: u4 - id: rsv2 type: u4 - id: crc32 type: u4 types: flash_cfg: seq: - id: magic_code size: 4 # contents: \u0026#34;FCFG\u0026#34; # BL706 have this empty :( - id: io_mode type: u1 - id: c_read_support type: u1 - id: clk_delay type: u1 - id: clk_invert type: u1 - id: reset_en_cmd type: u1 - id: reset_cmd type: u1 - id: reset_cread_cmd type: u1 - id: reset_cread_cmd_size type: u1 - id: jedec_id_cmd type: u1 - id: jedec_id_cmd_dmy_clk type: u1 - id: qpi_jedec_id_cmd type: u1 - id: qpi_jedec_id_cmd_dmy_clk type: u1 - id: sector_size type: u1 - id: mid type: u1 - id: page_size type: u2 - id: chip_erase_cmd type: u1 - id: sector_erase_cmd type: u1 - id: blk_32_erase_cmd type: u1 - id: blk_64_erase_cmd type: u1 - id: write_enable_cmd type: u1 - id: page_program_cmd type: u1 - id: qpage_program_cmd type: u1 - id: qpp_addr_mode type: u1 - id: fast_read_cmd type: u1 - id: fr_dmy_clk type: u1 - id: qpi_fast_read_cmd type: u1 - id: qpi_fr_dmy_clk type: u1 - id: fast_read_do_cmd type: u1 - id: fr_do_dmy_clk type: u1 - id: fast_read_dio_cmd type: u1 - id: fr_dio_dmy_clk type: u1 - id: fast_read_qo_cmd type: u1 - id: fr_qo_dmy_clk type: u1 - id: fast_read_qio_cmd type: u1 - id: fr_qio_dmy_clk type: u1 - id: qpi_fast_read_qio_cmd type: u1 - id: qpi_fr_qio_dmy_clk type: u1 - id: qpi_page_program_cmd type: u1 - id: write_vreg_enable_cmd type: u1 - id: wr_enable_index type: u1 - id: qe_index type: u1 - id: busy_index type: u1 - id: wr_enable_bit type: u1 - id: qe_bit type: u1 - id: busy_bit type: u1 - id: wr_enable_write_reg_len type: u1 - id: wr_enable_read_reg_len type: u1 - id: qe_write_reg_len type: u1 - id: qe_read_reg_len type: u1 - id: release_power_down type: u1 - id: busy_read_reg_len type: u1 - id: read_reg_cmd size: 4 - id: write_reg_cmd size: 4 - id: enter_qpi type: u1 - id: exit_qpi type: u1 - id: c_read_mode type: u1 - id: c_r_exit type: u1 - id: burst_wrap_cmd type: u1 - id: burst_wrap_cmd_dmy_clk type: u1 - id: burst_wrap_data_mode type: u1 - id: burst_wrap_data type: u1 - id: de_burst_wrap_cmd type: u1 - id: de_burst_wrap_cmd_dmy_clk type: u1 - id: de_burst_wrap_data_mode type: u1 - id: de_burst_wrap_data type: u1 - id: time_esector type: u2 - id: time_e_32_k type: u2 - id: time_e_64_k type: u2 - id: time_page_pgm type: u2 - id: time_ce type: u2 - id: pd_delay type: u1 - id: qe_data type: u1 - id: crc type: u4 clk_cfg: seq: - id: magic_code size: 4 # contents: \u0026#34;PCFG\u0026#34; # BL602 \u0026amp; BL706 have this empty - id: xtal_type type: u1 - id: pll_clk type: u1 - id: hclk_div type: u1 - id: bclk_div type: u1 - id: flash_clk_type type: u1 - id: flash_clk_div type: u1 - id: rsvd size: 2 - id: crc type: u4 boot_cfg: meta: bit-endian: le seq: - id: sign type: b2 - id: encrypt_type type: b2 - id: key_sel type: b2 - id: rsvd6_7 type: b2 - id: no_segment type: b1 - id: cache_enable type: b1 - id: notload_in_bootrom type: b1 - id: aes_region_lock type: b1 - id: cache_way_disable type: b4 - id: crc_ignore type: b1 - id: hash_ignore type: b1 - id: halt_ap type: b1 - id: rsvd19_31 type: b13 ","description":" Kaitai Script meta: id: bfnp file-extension: bin endian: le seq: - id: magic_code contents: \u0026#34;BFNP\u0026#34; - id: revision type: u4 - id: flash_cfg type: flash_cfg - id: clk_cfg type: clk_cfg - id: boot_cfg type: boot_cfg - id: segment_info type: u4 - id: boot_entry type: u4 - id: flash_offset type: u4 - id: hash size: 32 - id: rsv1 type: u4 - id: rsv2 type: u4 - id: crc32 type: u4 types: flash_cfg: seq: - id: magic_code size: 4 # contents: \u0026#34;FCFG\u0026#34; # BL706 have this empty :( - id: io_mode type: u1 - id: c_read_support type: u1 - id: clk_delay type: u1 - id: clk_invert type: u1 - id: reset_en_cmd type: u1 - id: reset_cmd type: u1 - id: reset_cread_cmd type: u1 - id: reset_cread_cmd_size type: u1 - id: jedec_id_cmd type: u1 - id: jedec_id_cmd_dmy_clk type: u1 - id: qpi_jedec_id_cmd type: u1 - id: qpi_jedec_id_cmd_dmy_clk type: u1 - id: sector_size type: u1 - id: mid type: u1 - id: page_size type: u2 - id: chip_erase_cmd type: u1 - id: sector_erase_cmd type: u1 - id: blk_32_erase_cmd type: u1 - id: blk_64_erase_cmd type: u1 - id: write_enable_cmd type: u1 - id: page_program_cmd type: u1 - id: qpage_program_cmd type: u1 - id: qpp_addr_mode type: u1 - id: fast_read_cmd type: u1 - id: fr_dmy_clk type: u1 - id: qpi_fast_read_cmd type: u1 - id: qpi_fr_dmy_clk type: u1 - id: fast_read_do_cmd type: u1 - id: fr_do_dmy_clk type: u1 - id: fast_read_dio_cmd type: u1 - id: fr_dio_dmy_clk type: u1 - id: fast_read_qo_cmd type: u1 - id: fr_qo_dmy_clk type: u1 - id: fast_read_qio_cmd type: u1 - id: fr_qio_dmy_clk type: u1 - id: qpi_fast_read_qio_cmd type: u1 - id: qpi_fr_qio_dmy_clk type: u1 - id: qpi_page_program_cmd type: u1 - id: write_vreg_enable_cmd type: u1 - id: wr_enable_index type: u1 - id: qe_index type: u1 - id: busy_index type: u1 - id: wr_enable_bit type: u1 - id: qe_bit type: u1 - id: busy_bit type: u1 - id: wr_enable_write_reg_len type: u1 - id: wr_enable_read_reg_len type: u1 - id: qe_write_reg_len type: u1 - id: qe_read_reg_len type: u1 - id: release_power_down type: u1 - id: busy_read_reg_len type: u1 - id: read_reg_cmd size: 4 - id: write_reg_cmd size: 4 - id: enter_qpi type: u1 - id: exit_qpi type: u1 - id: c_read_mode type: u1 - id: c_r_exit type: u1 - id: burst_wrap_cmd type: u1 - id: burst_wrap_cmd_dmy_clk type: u1 - id: burst_wrap_data_mode type: u1 - id: burst_wrap_data type: u1 - id: de_burst_wrap_cmd type: u1 - id: de_burst_wrap_cmd_dmy_clk type: u1 - id: de_burst_wrap_data_mode type: u1 - id: de_burst_wrap_data type: u1 - id: time_esector type: u2 - id: time_e_32_k type: u2 - id: time_e_64_k type: u2 - id: time_page_pgm type: u2 - id: time_ce type: u2 - id: pd_delay type: u1 - id: qe_data type: u1 - id: crc type: u4 clk_cfg: seq: - id: magic_code size: 4 # contents: \u0026#34;PCFG\u0026#34; # BL602 \u0026amp; BL706 have this empty - id: xtal_type type: u1 - id: pll_clk type: u1 - id: hclk_div type: u1 - id: bclk_div type: u1 - id: flash_clk_type type: u1 - id: flash_clk_div type: u1 - id: rsvd size: 2 - id: crc type: u4 boot_cfg: meta: bit-endian: le seq: - id: sign type: b2 - id: encrypt_type type: b2 - id: key_sel type: b2 - id: rsvd6_7 type: b2 - id: no_segment type: b1 - id: cache_enable type: b1 - id: notload_in_bootrom type: b1 - id: aes_region_lock type: b1 - id: cache_way_disable type: b4 - id: crc_ignore type: b1 - id: hash_ignore type: b1 - id: halt_ap type: b1 - id: rsvd19_31 type: b13 "},{"id":5,"href":"/chips/bl60x/bootrom/","title":"BootROM","parent":"BL60X","content":" General information Location: 0x21000000 - 0x21020000 Size: 128 KiB Can boot from: UART, SDIO, SPI Flash BootROM mode trigger: IO8 pulled HIGH Boot Info header structure Size: 20 Bytes\nByte 0 - 3 - BootROM version Byte 4 - Sign configuration Byte 5 - Encrypt configuration Byte 6 - 11 - Unknown Byte 12 - 17 - ChipID (MAC?) Byte 18 - 19 - Unknown Dumps File Chip Version Build Date Dumped by bl602-bootrom.bin BL602? TODO May 11 2020 gamiee ","description":"General information Location: 0x21000000 - 0x21020000 Size: 128 KiB Can boot from: UART, SDIO, SPI Flash BootROM mode trigger: IO8 pulled HIGH Boot Info header structure Size: 20 Bytes\nByte 0 - 3 - BootROM version Byte 4 - Sign configuration Byte 5 - Encrypt configuration Byte 6 - 11 - Unknown Byte 12 - 17 - ChipID (MAC?) Byte 18 - 19 - Unknown Dumps File Chip Version Build Date Dumped by bl602-bootrom."},{"id":6,"href":"/chips/bl70x/bootrom/","title":"BootROM","parent":"BL70X","content":" General information Location: 0x21000000 - 0x21020000 Size: 128 KiB Can boot from: USB, UART, SPI Flash BootROM mode trigger: IO28 pulled HIGH Boot Info header structure Size: 24 Bytes\nByte 0 - 3 - BootROM version Byte 4 - Sign configuration Byte 5 - Encrypt configuration Byte 6 - 15 - Unknown Byte 16 - 23 - ChipID (Something related to MAC) Dumps File Chip Version Build Date Dumped by bl706-bootrom.bin BL706? TODO May 14 2020 gamiee ","description":"General information Location: 0x21000000 - 0x21020000 Size: 128 KiB Can boot from: USB, UART, SPI Flash BootROM mode trigger: IO28 pulled HIGH Boot Info header structure Size: 24 Bytes\nByte 0 - 3 - BootROM version Byte 4 - Sign configuration Byte 5 - Encrypt configuration Byte 6 - 15 - Unknown Byte 16 - 23 - ChipID (Something related to MAC) Dumps File Chip Version Build Date Dumped by bl706-bootrom."},{"id":7,"href":"/chips/bl808/bootrom/","title":"BootROM","parent":"BL808","content":" Dumps File Chip Version Build Date Dumped by bl808c-01000808-bootrom.bin BL808C 1.0.8.8 Sep 29 2021, 17:07:23 gamiee ","description":" Dumps File Chip Version Build Date Dumped by bl808c-01000808-bootrom.bin BL808C 1.0.8.8 Sep 29 2021, 17:07:23 gamiee "},{"id":8,"href":"/chips/","title":"Chips","parent":"","content":"","description":""},{"id":9,"href":"/chips/bl70x/efuse/","title":"eFuse","parent":"BL70X","content":" Applies to BL702, BL704 and BL706\nSize: 1Kbit\neFuse is one time programmable memory. It\u0026rsquo;s mostly used to store things like MAC Address, encryption keys and all other stuff, which are not possible to change after it being burned into eFuse.\nIn case of BL70X eFuse, once you burn the bit in eFuse, it\u0026rsquo;s not possible to revert it. You can also write/read lock of specific eFuse slots/areas.\nThe structure of the eFuse is available in Bouffalo\u0026rsquo;s SDK and bfl_mcu_tools (file efuse_cfg_keys.py), although, it doesn\u0026rsquo;t contains all properties.\nFree eFuse slots for user application NOTE: This still work in progress and those information still can be not true\nThe slots ef_key_slot_4_w0 and ef_key_slot_4_w1 seems not to be used by any code.\nIf encryption is not used, slots from ef_key_slot_0_w0 to ef_key_slot_3_w3 can be free for the user application.\nTable of eFuse structure Name Byte Offset Bit index Length (bits) Used in Notes Verified ef_sf_aes_mode 0 (0x0) 0 2 TBD 0 - disabled, 1 - 32 bit AES key, 2 - 48 bit key, 3 - 64 bit key No ef_sboot_sign_mode 0 (0x0) 2 2 No ef_sboot_en 0 (0x0) 4 2 No ef_cpu_enc_en 0 (0x0) 7 1 No trim_enable 0 (0x0) 12 1 No ef_sw_usage_1 0 (0x0) 13 1 No ef_sdu_dis 0 (0x0) 14 1 No ef_ble_dis 0 (0x0) 15 1 No ef_wifi_dis 0 (0x0) 16 1 No ef_0_key_enc_en 0 (0x0) 17 1 No ef_sf_dis 0 (0x0) 19 1 No ef_cpu_rst_dbg_dis 0 (0x0) 21 1 No ef_se_dbg_dis 0 (0x0) 22 1 No ef_efuse_dbg_dis 0 (0x0) 23 1 No ef_dbg_jtag_dis 0 (0x0) 26 2 No ef_dbg_mode 0 (0x0) 28 4 No ef_dbg_pwd_low 4 (0x4) 0 32 No ef_dbg_pwd_high 8 (0x8) 0 32 No ef_ana_trim_0 12 (0xC) 0 32 No ef_sw_usage_0 16 (0x10) 0 32 No bootrom_protect 16 (0x10) 0 1 No uart_log_disable 16 (0x10) 1 1 No sdio_pin_init 16 (0x10) 2 1 No disable_cci_coexist 16 (0x10) 3 1 No xtal_type 16 (0x10) 4 3 No pll_clk 16 (0x10) 7 3 No hclk_div 16 (0x10) 10 1 No bclk_div 16 (0x10) 11 1 No flash_clk_type 16 (0x10) 12 3 No flash_clk_div 16 (0x10) 15 1 No flash_cfg 16 (0x10) 16 2 No flash_pwr_delay 16 (0x10) 18 2 No tz_boot 16 (0x10) 20 1 No encrypted_tz_boot 16 (0x10) 21 1 No hbn_check_sign 16 (0x10) 22 1 No keep_dbg_port_closed 16 (0x10) 23 1 No mediaboot_disable 16 (0x10) 24 1 No uartboot_disable 16 (0x10) 25 1 No sdioboot_disable 16 (0x10) 26 1 No hbn_jump_disable 16 (0x10) 27 1 No jtag_switch 16 (0x10) 28 1 No jtag_init 16 (0x10) 29 1 No qfn40 16 (0x10) 30 1 No debug_log_reopen 16 (0x10) 31 1 No ef_wifi_mac_low 20 (0x14) 0 32 BootROM, eflash_loader, boot2 Lower part of MAC Address (BT/WIFI), also used as ChipID Yes ef_wifi_mac_high 24 (0x18) 0 32 BootROM, eflash_loader, boot2 Higher part of MAC Address (BT/WIFI), also used as ChipID Yes ef_key_slot_0_w0 28 (0x1C) 0 32 TBD Public key hash, when ef_sboot_sign_mode is 1 [0:8 bytes of hash] Yes ef_key_slot_0_w1 32 (0x20) 0 32 TBD Public key hash, when ef_sboot_sign_mode is 1 [8:16 bytes of hash] Yes ef_key_slot_0_w2 36 (0x24) 0 32 TBD Public key hash, when ef_sboot_sign_mode is 1 [16:24 bytes of hash] Yes ef_key_slot_0_w3 40 (0x28) 0 32 TBD Public key hash, when ef_sboot_sign_mode is 1 [24:32 bytes of hash] Yes ef_key_slot_1_w0 44 (0x2C) 0 32 TBD Public key hash, when ef_sboot_sign_mode is 1 [32:40 bytes of hash] Yes ef_key_slot_1_w1 48 (0x30) 0 32 TBD Public key hash, when ef_sboot_sign_mode is 1 [40:48 bytes of hash] Yes ef_key_slot_1_w2 52 (0x34) 0 32 TBD Public key hash, when ef_sboot_sign_mode is 1 [48:56 bytes of hash] Yes ef_key_slot_1_w3 56 (0x38) 0 32 TBD Public key hash, when ef_sboot_sign_mode is 1 [56:64 bytes of hash] Yes ef_key_slot_2_w0 60 (0x3C) 0 32 TBD AES key (aes_mode == 1, 2, 3) Yes ef_key_slot_2_w1 64 (0x40) 0 32 TBD AES key (aes_mode == 1, 2, 3) Yes ef_key_slot_2_w2 68 (0x44) 0 32 TBD AES key (aes_mode == 1, 2, 3) Yes ef_key_slot_2_w3 72 (0x48) 0 32 TBD AES key (aes_mode == 1, 2, 3) Yes ef_key_slot_3_w0 76 (0x4C) 0 32 TBD AES key (aes_mode == 2, 3) Yes ef_key_slot_3_w1 80 (0x50) 0 32 TBD AES key (aes_mode == 2, 3) Yes ef_key_slot_3_w2 84 (0x54) 0 32 TBD AES key (aes_mode == 3) Yes ef_key_slot_3_w3 88 (0x58) 0 32 TBD AES key (aes_mode == 3) Yes ef_key_slot_4_w0 92 (0x5C) 0 32 TBD Empty? No ef_key_slot_4_w1 96 (0x60) 0 32 TBD Empty? No ef_key_slot_4_w2 100 (0x64) 0 32 TBD Customer VID (0xFFFF0000) \u0026amp; PID (0x0000FFFF) Yes ef_key_slot_4_w3 104 (0x68) 0 32 TBD Chip VID (0xFFFF0000) \u0026amp; PID (0x0000FFFF) Yes ef_key_slot_5_w0 108 (0x6C) 0 32 TBD Optional MAC Address slot (low) Yes ef_key_slot_5_w1 112 (0x70) 0 32 TBD Optional MAC Address slot (high) Yes ef_key_slot_5_w2 116 (0x74) 0 32 TBD Device Info structure (TBD) Yes ef_key_slot_5_w3 120 (0x78) 0 32 TBD CapCode (TBD) No wr_lock_key_slot_4_l 124 (0x7C) 13 1 No wr_lock_key_slot_5_l 124 (0x7C) 14 1 No wr_lock_boot_mode 124 (0x7C) 15 1 No wr_lock_dbg_pwd 124 (0x7C) 16 1 No wr_lock_sw_usage_0 124 (0x7C) 17 1 No wr_lock_wifi_mac 124 (0x7C) 18 1 Write lock for MAC Address eFuse (by default burned from factory) Yes wr_lock_key_slot_0 124 (0x7C) 19 1 No wr_lock_key_slot_1 124 (0x7C) 20 1 No wr_lock_key_slot_2 124 (0x7C) 21 1 No wr_lock_key_slot_3 124 (0x7C) 22 1 No wr_lock_key_slot_4_h 124 (0x7C) 23 1 No wr_lock_key_slot_5_h 124 (0x7C) 24 1 No rd_lock_dbg_pwd 124 (0x7C) 25 1 No rd_lock_key_slot_0 124 (0x7C) 26 1 No rd_lock_key_slot_1 124 (0x7C) 27 1 No rd_lock_key_slot_2 124 (0x7C) 28 1 No rd_lock_key_slot_3 124 (0x7C) 29 1 No rd_lock_key_slot_4 124 (0x7C) 30 1 No rd_lock_key_slot_5 124 (0x7C) 31 1 No ","description":"Applies to BL702, BL704 and BL706\nSize: 1Kbit\neFuse is one time programmable memory. It\u0026rsquo;s mostly used to store things like MAC Address, encryption keys and all other stuff, which are not possible to change after it being burned into eFuse.\nIn case of BL70X eFuse, once you burn the bit in eFuse, it\u0026rsquo;s not possible to revert it. You can also write/read lock of specific eFuse slots/areas.\nThe structure of the eFuse is available in Bouffalo\u0026rsquo;s SDK and bfl_mcu_tools (file efuse_cfg_keys."},{"id":10,"href":"/chips/bl808/efuse/","title":"eFuse","parent":"BL808","content":" Description of sw_usage_0/1 The eFuse words sw_usage_0 and sw_usage_1 control the boot ROM behavior of the BL808. The field names in the following table come from the SDK, but the semantics are not specified anywhere (except where they can reasonably be derived from the name). In the following table, additional information derived from reverse-engineering the boot ROM has been added. Code references are with respect to the Sep 29 2021 17:07:23 version of the boot ROM.\nThe default values of these words on the Ox64 and M1s dock boards are identical, namely:\nsw_usage_0 == 0x02c1140b: 28 24 20 16 12 8 4 0 0000 0010 1100 0001 0001 0100 0000 1011 sw_usage_1 == 0x18fbf42f 28 24 20 16 12 8 4 0 0001 1000 1111 1011 1111 0100 0010 1111 sw_usage_0 Field name Bit offset Field width Default value Description bootrom_protect 0 1 1 Code at 0x900140b0. Executed before jumping to user code. Presumably disables access to the boot ROM. uart_log_disable 1 1 1 Boot ROM debugging, see notes boot_pin_cfg 2 1 0 Bootloader entry GPIO. 0: GPIO39, 1: GPIO8 uart_download_cfg 3 1 1 Bootloader UART (UART0) pins (RX/TX): 0: GPIO20/21, 1: GPIO14/15 mediaboot_disable 4 1 0 Do not attempt boot from SPI/SD storage, but see note uartboot_disable 5 1 0 Disables bootloader communication via UART usbboot_enable 6 1 0 Enable bootloader communication via USB (broken in ROM version Sep 29 2021 17:07:23. Do not set, will crash on bootloader entry) uart_log_reopen 7 1 0 Boot ROM debugging, see notes sign_cfg 8 1 0 dcache_disable 9 1 0 Disable M0 dcache jtag_cfg 10 2 01 (1) JTAG pin configuration. 0: GPIO16-19, 1: GPIO6/7/12/13, 2/3: disabled fix_key_sel 12 1 1 sdh_en 13 1 0 Enable boot from SD card (untested) sf_pin_cfg 14 5 00100 (4) Flash IO pin configuration, equivalent to enum SF_Ctrl_Pin_Select boot_level_revert 19 1 0 Bootloader entry GPIO polarity. 0: active high, 1: active low boot_pin_dly 20 2 00 (0) Time to wait between configuring and sampling bootloader entry GPIO. 0: 5us, 1: 10us, 2: 100us, 3: 500us ldo_trim_enable 22 1 1 Apply LDO18 trimming from eFuse (0x78, see F_Ctrl_Read_LDO18IO_Vout_Trim trim_enable 23 1 1 Apply RC32m trimming from eFuse (0x00, see F_Ctrl_Read_Xtal_Trim_RC32M no_hd_boot_en 24 1 0 flash_power_delay 25 2 01 (1) Time to wait after power-cycling the flash (via GLB_PU_LDO18FLASH). 0: none, 1: 1ms, 2: 8ms, 3: 16ms tz_boot 27 1 0 Wide-ranging effects. Disables some bootloader protocol commands (such as WRITE_MEMORY). Disallows ROM-based setup of cores other than M0. encrypted_tz_boot 28 1 0 hbn_check_sign 29 1 0 keep_dbg_port_closed 30 1 0 Code at 0x900140b0. Executed before jumping to user code. Sets TZC_SEC_TZC_SBOOT_DONE to all-ones. hbn_jump_disable 31 1 0 Notes:\nBoot ROM debug output is disabled if and only if uart_log_disable == 1 \u0026amp;\u0026amp; uart_log_reopen == 0. Since uart_log_disable is set on all available devboards, burning uart_log_reopen enables boot ROM debugging on the UART selected by bootlog_pin_cfg. Even if mediaboot_disable is set, media boot will still be attempted if both the UART and USB bootloader protocols are disabled (i.e. usbboot_enable == 0 \u0026amp;\u0026amp; uartboot_disable == 1) sw_usage_1 Field name Bit offset Field width Default value Description xtal_type 0 3 111 (7) wifipll_pu 3 1 1 aupll_pu 4 1 0 cpupll_pu 5 1 1 mipipll_pu 6 1 0 uhspll_pu 7 1 0 mcu_clk 8 3 100 (4) mcu_clk_div 11 1 0 mcu_pbclk_div 12 2 11 (3) lp_div 14 1 1 dsp_clk 15 2 11 (3) dsp_clk_div 17 1 1 dsp_pbclk 18 2 10 (2) emi_clk 20 2 11 (3) emi_clk_div 22 1 1 flash_clk_type 23 3 001 (1) flash_clk_div 26 1 0 ldo18flash_bypass_cfg 27 1 1 Sets GLB_LDO18FLASH_BYPASS bootlog_pin_cfg 28 1 1 Boot ROM debug UART (UART1) output pin. 0: GPIO39, 1: GPIO8 abt_offset 29 1 0 Bootloader UART autobaud tolerance (see UART_SetAllowableError0X55). 0: 7, 1: 3 boot_pull_cfg 30 1 0 Boot pin pull direction. 0: down, 1: up usb_if_int_disable 31 1 0 Disable USB interrupts before jumping to user code Notes:\nThe clock tree config fields are equivalent to the corresponding fields in struct hal_sys_clk_config. The config is only applied if xtal_type != 0. ","description":"Description of sw_usage_0/1 The eFuse words sw_usage_0 and sw_usage_1 control the boot ROM behavior of the BL808. The field names in the following table come from the SDK, but the semantics are not specified anywhere (except where they can reasonably be derived from the name). In the following table, additional information derived from reverse-engineering the boot ROM has been added. Code references are with respect to the Sep 29 2021 17:07:23 version of the boot ROM."},{"id":11,"href":"/chips/bl70x/errata/","title":"Errata","parent":"BL70X","content":" Applies to BL702, BL704 and BL706\nIssues with running image loaded by BootROM For some reason, BOOTROM_RUN_IMAGE (0x1A) command in BootROM, doesn\u0026rsquo;t work properly, and because of it, eflash_loader have issues with initializing USB (so sometimes in Windows, the UART driver freeze, so it can\u0026rsquo;t communicate with eflash_loader). (NOTE: This is observation, other issues are not known yet)\nTo workaround this, there are three registers set, via BOOTROM_WRITE_MEM (0x50) command in BootROM:\n0x4000F100 =\u0026gt; 0x4E424845 (This sets RSV0 to HBN_STATUS_ENTER_FLAG in Deep Sleep Control (Hibernate) core, in SDK it is used as set STATUS flag. (gamiee: My guess is that BootROM read this after CPU reset?)) 0x4000F104 =\u0026gt; 0x22010000 (This sets RSV1 register in Hibernate core, in SDK it is used as WakeUp Address, and exactly we write the launch address, where eflash_loader should be) (gamiee: those reserved registers in HBN does nothing at all, just those values are preserved between CPU Resets) 0x40000018 =\u0026gt; 0x00000002 (This sets swrst_cfg2 register in Global Control Register, enabling register reg_ctrl_cpu_reset) You can find this workaround in bflb_mcu_tool in file bflb_mcu_tool/libs/bl702/chiptype_patch.py.\n","description":"Applies to BL702, BL704 and BL706\nIssues with running image loaded by BootROM For some reason, BOOTROM_RUN_IMAGE (0x1A) command in BootROM, doesn\u0026rsquo;t work properly, and because of it, eflash_loader have issues with initializing USB (so sometimes in Windows, the UART driver freeze, so it can\u0026rsquo;t communicate with eflash_loader). (NOTE: This is observation, other issues are not known yet)\nTo workaround this, there are three registers set, via BOOTROM_WRITE_MEM (0x50) command in BootROM:"},{"id":12,"href":"/tags/","title":"Tags","parent":"","content":"","description":""}]